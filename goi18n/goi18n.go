// Copyright 23-Aug-2017 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/*
Internationalization management.

Goi18n Use

From command line use:
  goi18n <package> <languages>
For example:
  goi18n mypack en-es_ES

Goi18n Operations

goi18n do next operations:

  1. Creates directory "i18n" in <package> and inside it creates so many
     files .txt as indicated <languages>.
  2. Reads all files ".go" in <package> and all its subdirectories, extracting
     those strings which have keys to translate.
  3. Updates .txt files.
  4. Creates-Updates file "<package>/i18n.go"

Process of Use

goi18n requires next use cycle:

  1. Run goi18n in the inmediate superior directory of package
     (e.g.: goi18n myapp en-es)
  2. Modify .txt files translating keys
  3. Rerun goi18n to update "<package>/i18n.go"
  4. Recompile package (which will include "i18n.go")

Annotation of keys

You have to mark keys to translate using 'I_("key")'.

For example:
  fmt.Println(I_("A message"))
The expression I_(" must be written as is, without inner spaces or tabulations.

Key Syntax

Keys are ordinary strings, but they must not include the rune '='.

Translation Syntax

You have to put the translation after the first rune '='.

Translations must be written like strings in code.

For example:
  That is a \"problem\".\nDon't forget it.

Translations marked as "ORPHAN" have nonexistent keys. If there are no error,
they should be deleted.

Keys marked as "TO DO" are pending translation.

Example of txt File

Example of file "es.txt":
  # File generated by goi18n.

  # mypack/hello.go: 25
  Hello = Hola

  # mypack/hello.go: 48
  problem = Esto es un \"problema\".\nNo olvidarlo.

  # mypack/hello.go: 5
  start = comienzo
Lines commented with '#' and keys are automatically written by goi18n. User
should write only after "=".

Use of File i18n

i18n.go can be used by program following next process:
  1. Set variable 'I18n_lang' with one of available dictionaries.
     For example: I18n_lang = I18n_es
  2. Use functions 'I_' and 'I_args' to write keys

If a key is not in dictionary, 'I_' and 'I_args' will yield it without
modification; otherwise it will be translated.

Example of use:
  func main() {
    I18n_lang = I18n_es
    ...
    fmt.Println(I_("Hello"))
    ...
    day, hour := "3", "14"
    fmt.Println(I_args(I_("Day %0, at %1 p.m."), day, hour))
    ...
  }
  =>
  Hola
  Dia 3, a las 14 p.m.
'I_args' allows arguments '0' to '9'. Each argument matches a variable. '0'
matches the first variable, '1' the second and so on.

Each argument can appear more than one time.
*/
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"
)

// dmio functions ------------------------------------------

func Exists(path string) bool {
	if _, err := os.Stat(path); err == nil {
		return true
	}
	return false
}

func IsDirectory(path string) bool {
	if info, err := os.Stat(path); err == nil && info.IsDir() {
		return true
	}
	return false
}

func Wopen(path string) *os.File {
	f, err := os.OpenFile(path, os.O_TRUNC|os.O_WRONLY|os.O_CREATE, 0755)
	if err != nil {
		log.Fatal(err)
	}
	return f
}

func Ropen(path string) *os.File {
	f, err := os.Open(path)
	if err != nil {
		log.Fatal(err)
	}
	return f
}

func Write(file *os.File, text string) {
	_, err := file.WriteString(text)
	if err != nil {
		log.Fatal(err)
	}
}

func Lines(path string, f func(s string)) {
	file := Ropen(path)
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		f(scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
}

// END dmio functions --------------------------------------

func help(msg string) {
	fmt.Println(msg + "\n" +
		"Use:\n" +
		"  goi18n <package> <languages>\n" +
		"For example:\n" +
		"  goi18n mypack en-es_ES\n")
}

type pos struct {
	file string
	line int
}

type strs []string

func (ss strs) Len() int {
	return len(ss)
}

func (ss strs) Less(i, j int) bool {
	return strings.ToLower(ss[i]) < strings.ToLower(ss[j])
}

func (ss strs) Swap(i, j int) {
	ss[i], ss[j] = ss[j], ss[i]
}

type keys map[string][]*pos // key: position

type oldDic map[string]string // key: translation

func rdoc(text string) string {
	text = strings.Replace(text, "\\\"", "\"", -1)
	return strings.Replace(text, "\"", "\\\"", -1)
}

func extract(ks keys, p string) keys {
	readFile := func() {
		const (
			CODE = iota
			PRECOMMENT
			LCOMMENT
			BCOMMENT
			BCOMMENT2
			QUOTE
			QUOTE2
			ENTRY1
			ENTRY2
			ENTRY3
			EQUOTE
			EQUOTE2
		)
		codeState := func(ch rune) int {
			switch ch {
			case '/':
				return PRECOMMENT
			case '"':
				return QUOTE
			case 'I':
				return ENTRY1
			}
			return CODE
		}
		bf := new(bytes.Buffer)
		state := CODE
		nl := 1
		Lines(p, func(l string) {
			for _, ch := range l {
				switch state {
				case PRECOMMENT:
					switch ch {
					case '/':
						state = LCOMMENT
					case '*':
						state = BCOMMENT
					default:
						state = codeState(ch)
					}
				case LCOMMENT:
				case BCOMMENT:
					if ch == '*' {
						state = BCOMMENT2
					}
				case BCOMMENT2:
					if ch == '/' {
						state = CODE
					} else {
						state = BCOMMENT
					}
				case QUOTE:
					switch ch {
					case '"', '\n':
						state = CODE
					case '\\':
						state = QUOTE2
					}
				case QUOTE2:
					state = QUOTE
				case ENTRY1:
					if ch == '_' {
						state = ENTRY2
					} else {
						state = codeState(ch)
					}
				case ENTRY2:
					if ch == '(' {
						state = ENTRY3
					} else {
						state = codeState(ch)
					}
				case ENTRY3:
					if ch == '"' {
						state = EQUOTE
					} else {
						state = codeState(ch)
					}
				case EQUOTE:
					switch ch {
					case '"', '\n':
						if ch == '"' {
							key := bf.String()
							if strings.Index(key, "=") == -1 {
								value := &pos{p, nl}
								data, ok := ks[key]
								if ok {
									ks[key] = append(data, value)
								} else {
									ks[key] = []*pos{value}
								}
							}
						}
						bf = new(bytes.Buffer)
						state = CODE
					case '\\':
						bf.WriteRune(ch)
						state = EQUOTE2
					default:
						bf.WriteRune(ch)
					}
				case EQUOTE2:
					bf.WriteRune(ch)
					state = EQUOTE
				default:
					state = codeState(ch)
				}
			}
			if state == LCOMMENT {
				state = CODE
			}
			nl++
		})
	}
	if IsDirectory(p) {
		files, _ := ioutil.ReadDir(p)
		for _, file := range files {
			ks = extract(ks, path.Join(p, file.Name()))
		}
	} else {
		if path.Ext(p) == ".go" {
			readFile()
		}
	}
	return ks
}

func makeDic(ks keys, pack string, lang string) string {
	dir := path.Join(pack, "i18n")
	if !Exists(dir) {
		os.Mkdir(dir, 0755)
	}

	filePath := path.Join(dir, lang+".txt")
	if !Exists(filePath) {
		Wopen(filePath).Close()
	}

	oldD := make(oldDic)
	Lines(filePath, func(l string) {
		l = strings.TrimSpace(l)
		if l == "" || l[0] == '#' {
			return
		}
		ix := strings.Index(l, "=")
		if ix == -1 {
			return
		}
		key := strings.TrimSpace(l[:ix])
		value := strings.TrimSpace(l[ix+1:])
		if key != "" && value != "" {
			oldD[rdoc(key)] = rdoc(value)
		}
	})

	orphan := ""
	todo := ""
	trans := ""
	dic := ""

	var kks strs
	for k := range ks {
		kks = append(kks, k)
	}
	sort.Sort(kks)
	for _, k := range kks {
		poss := ks[k]
		v, ok := oldD[k]
		if ok {
			for _, p := range poss {
				trans = trans + "# " + p.file + ": " + strconv.Itoa(p.line) + "\n"
			}
			trans = trans + k + " = " + v + "\n\n"
			dic = dic + "\t\"" + k + "\":  \"" + v + "\",\n"
			delete(oldD, k)
		} else {
			todo = todo + "# TO DO\n"
			for _, p := range poss {
				trans = trans + "# " + p.file + ": " + strconv.Itoa(p.line) + "\n"
			}
			trans = trans + k + " = \n\n"
		}
	}

	var oks strs
	for k := range oldD {
		oks = append(oks, k)
	}
	sort.Sort(oks)
	for _, k := range oks {
		orphan = orphan + "# ORPHAN\n" +
			k + " = " + oldD[k] + "\n\n"
	}

	fdic := Wopen(filePath)
	Write(fdic, "# File generated by goi18n.\n\n")
	Write(fdic, orphan)
	Write(fdic, todo)
	Write(fdic, trans)
	fdic.Close()

	return dic
}

func main() {
	if len(os.Args) != 3 {
		help("Missing package name and/or languages")
		return
	}
	pack := os.Args[1]
	langs := strings.Split(os.Args[2], "-")
	if !IsDirectory(pack) {
		help("'" + pack + "' is not a directory")
		return
	}

	ks := extract(make(keys), pack)

	gotarget := path.Join(pack, "i18n.go")

	fgotarget := Wopen(gotarget)
	defer fgotarget.Close()

	Write(fgotarget,
		`// Generate by goi18n. Don't modify

package main

import "bytes"

`)

	for _, lang := range langs {
		dic := makeDic(ks, pack, lang)
		Write(fgotarget, "var I18n_"+lang+" = map[string]string{\n"+
			dic+
			"}\n\n")
	}

	Write(fgotarget,
		`var I18n_lang map[string]string

func I_(key string) string {
  k, ok := I18n_lang[key]
  if ok {
    return k
  }
  return key
}

func I_args(key string, args ...string) string {
  var bf bytes.Buffer
  k := I_(key)
  isCode := false
  for _, ch := range k {
    if isCode {
      switch ch {
      case '0':
        bf.WriteString(args[0])
      case '1':
        bf.WriteString(args[1])
      case '2':
        bf.WriteString(args[2])
      case '3':
        bf.WriteString(args[3])
      case '4':
        bf.WriteString(args[4])
      case '5':
        bf.WriteString(args[5])
      case '6':
        bf.WriteString(args[6])
      case '7':
        bf.WriteString(args[7])
      case '8':
        bf.WriteString(args[8])
      case '9':
        bf.WriteString(args[9])
      case '%':
        bf.WriteRune('%')
      default:
        bf.WriteRune('%')
        bf.WriteRune(ch)
      }
      isCode = false
    } else {
      if ch == '%' {
        isCode = true
      } else {
        bf.WriteRune(ch)
      }
    }
  }
  return bf.String()
}
`)
}
